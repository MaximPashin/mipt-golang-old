
<!DOCTYPE html>
<html>
  <head>
    <title>Лекция 2. Базовые конструкции языка</title>
    <meta charset='utf-8'>
    <link rel="icon" href="static/favicon.ico">
    <script>
      var notesEnabled =  false ;
    </script>
    <script src='static/slides.js'></script>

    

    <script>
      
      if (window["location"] && window["location"]["hostname"] == "talks.golang.org") {
        var _gaq = _gaq || [];
        _gaq.push(["_setAccount", "UA-11222381-6"]);
        _gaq.push(["b._setAccount", "UA-49880327-6"]);
        window.trackPageview = function() {
          _gaq.push(["_trackPageview", location.pathname+location.hash]);
          _gaq.push(["b._trackPageview", location.pathname+location.hash]);
        };
        window.trackPageview();
        window.trackEvent = function(category, action, opt_label, opt_value, opt_noninteraction) {
          _gaq.push(["_trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
          _gaq.push(["b._trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
        };
      }
    </script>
  </head>

  <body style='display: none'>

    <section class='slides layout-widescreen'>

      <article>
        <h1>Лекция 2. Базовые конструкции языка</h1>
        
        
        
      </article>

  
  
      <article >
      
        <h2>Должны начинаться с буквы (unicode) или символа `_`</h2>
      
      <span class="pagenumber">2</span>
      </article>
  
  
  
      <article >
      
        <h2>Могут содержать в себе буквы (unicode), цифры и символ `_`</h2>
      
      <span class="pagenumber">3</span>
      </article>
  
  
  
      <article >
      
        <h2>Регистр имеет значение (`hello` и `Hello` - разные имена)</h2>
      
      <span class="pagenumber">4</span>
      </article>
  
  
  
      <article >
      
        <h3>Регистр первой буквы влияет на область видимости глобальных переменных, констант, функций и типов:</h3>
        
  
  <div class="code"><pre>var Foo = &#34;foo&#34; // можно обращаться из других пакетов
var bar = &#34;bar&#34; // можно обращаться только из того же пакета</pre></div>
  

      
      <span class="pagenumber">5</span>
      </article>
  
  
  
      <article >
      
        <h2>Имена не имеют ограничений на длину, однако, принято, чтобы маложивущие объекты имели краткое и лаконичное название</h2>
      
      <span class="pagenumber">6</span>
      </article>
  
  
  
      <article >
      
        <h2>Для именования используется `CamelCase`, `snake_case` допустим синтаксически, но никто его не использует</h2>
      
      <span class="pagenumber">7</span>
      </article>
  
  
  
      <article >
      
        <h2>Сокращения аббревиатур: `htmlTags` (не `hTMLTags`), `HTMLTags` (не `HtmlTags`), `marshalJSON` (не `marshalJson`)</h2>
      
      <span class="pagenumber">8</span>
      </article>
  
  
  
      <article >
      
        <h3>Ключевые слова не могут быть использованы в качестве имен:</h3>
        
  
  <div class="code"><pre>break     default     func    interface   select
case      defer       go      map         struct
chan      else        goto    package     switch
const     fallthrough if      range       type
continue  for         import  return      var</pre></div>
  

      
      <span class="pagenumber">9</span>
      </article>
  
  
  
      <article >
      
        <h3>Кроме этого, есть `predeclared` имена, которые могут использоваться в качестве имен других объектов</h3>
        
  
  <div class="code"><pre>true false iota nil

int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64
uintptr float32 float64 complex128
complex64 bool byte
rune string error

make len cap new append copy close delete complex real imag
panic recover</pre></div>
  

      
      <span class="pagenumber">10</span>
      </article>
  
  
  
      <article >
      
        <h2>`var` - объявление переменной</h2>
      
      <span class="pagenumber">11</span>
      </article>
  
  
  
      <article >
      
        <h2>`const` - объявление константы</h2>
      
      <span class="pagenumber">12</span>
      </article>
  
  
  
      <article >
      
        <h2>`type` - объявление пользовательского типа</h2>
      
      <span class="pagenumber">13</span>
      </article>
  
  
  
      <article >
      
        <h3>`func` - объявление функции или метода</h3>
        
  
  <div class="code"><pre>var name type = expression</pre></div>
  

      
      <span class="pagenumber">14</span>
      </article>
  
  
  
      <article >
      
        <h2>`type` или `expression` могут отсутствовать, но не оба одновременно</h2>
      
      <span class="pagenumber">15</span>
      </article>
  
  
  
      <article >
      
        <h2>При отсутствии инициализации, переменная инициализируется `zero value` (0, &#34;&#34;, nil и т.д.)</h2>
      
      <span class="pagenumber">16</span>
      </article>
  
  
  
      <article >
      
        <h3>Можно объявить несколько переменных (и в том числе инициализировать их):</h3>
        
  
  <div class="code"><pre>var i, j int = 1, 2
var name, value = &#34;number&#34;, 42 // типы могут быть разными, но только если они выводятся</pre></div>
  

      
      <span class="pagenumber">17</span>
      </article>
  
  
  
      <article >
      
        <h3>Глобальные переменные инициализируются (и выделяются в памяти) до вызова `main`,</h3>
        
  
  <p>
    локальные переменные инициализируются в момент выполнения их определения
<br>

    * Несколько переменных могут быть инициализированы результатом вызова функции:
  </p>
  

  
  <div class="code"><pre>var f, err = os.Open(&#34;filename.txt&#34;)</pre></div>
  

      
      <span class="pagenumber">18</span>
      </article>
  
  
  
      <article >
      
        <h3>Если объявление переменной происходит совместно с ее инициализацией, то можно использовать краткий синтаксис:</h3>
        
  
  <div class="code"><pre>name := expression // var name = expression</pre></div>
  

      
      <span class="pagenumber">19</span>
      </article>
  
  
  
      <article >
      
        <h2>Краткий синтаксис не может быть использован для глобальных переменных</h2>
      
      <span class="pagenumber">20</span>
      </article>
  
  
  
      <article >
      
        <h3>Хотя бы одна из переменных должна быть необъявленной, в этом случае для уже объявленных переменных</h3>
        
  
  <p>
    будет вызвано просто присваивание
  </p>
  

  
  <div class="code"><pre>i, j := 0, 1 // ok
i, j := 2, 3 // error, i and j already declared
x, i := 2, 3 // ok
i, j = 2, 3  // ok</pre></div>
  

      
      <span class="pagenumber">21</span>
      </article>
  
  
  
      <article >
      
        <h2>Обычно для переменных, инициализируемых `zero value` (т.е. без инициализации) используют синтаксис с `var`</h2>
      
      <span class="pagenumber">22</span>
      </article>
  
  
  
      <article >
      
        <h2>Указатель хранит адрес некоторой области в памяти (почти всегда - переменной)</h2>
      
      <span class="pagenumber">23</span>
      </article>
  
  
  
      <article >
      
        <h2>`&amp;` - взятие адреса, `*` - разыменование адреса</h2>
      
      <span class="pagenumber">24</span>
      </article>
  
  
  
      <article >
      
        <h2>Для типа `T` тип указателя на переменную этого типа - `*T` (может быть указатель на указатель и т.д.)</h2>
      
      <span class="pagenumber">25</span>
      </article>
  
  
  
      <article >
      
        <h2>Указатели можно сравнивать, но не выполнять арифметические операции</h2>
      
      <span class="pagenumber">26</span>
      </article>
  
  
  
      <article >
      
        <h3>С некоторым упрощением указатели - это другие имена для одной и той же переменной, изменение через указатель</h3>
        
  
  <p>
    меняет значение исходной переменной
<br>

    * Так как аргументы функции всегда передаются по значению, то чтобы функция могла изменять переменную вовне
<br>

    надо передать указатель
  </p>
  

      
      <span class="pagenumber">27</span>
      </article>
  
  
  
      <article >
      
        <h3>Принимает в качестве аргумента тип, создает неименованную переменную этого типа и возвращает на нее указатель</h3>
        
  
  <div class="code"><pre>x := new(int) // то же самое, что var dummy int; x = &amp;dummy</pre></div>
  

      
      <span class="pagenumber">28</span>
      </article>
  
  
  
      <article >
      
        <h3>Функция `new` всегда возвращает адрес новой переменной (возможное исключение - пустые типы размера 0,</h3>
        
  
  <p>
    например <code>struct{}</code> или <code>[0]int</code>)
  </p>
  

      
      <span class="pagenumber">29</span>
      </article>
  
  
  
      <article >
      
        <h2>Для глобальных переменных - все время исполнения программы</h2>
      
      <span class="pagenumber">30</span>
      </article>
  
  
  
      <article >
      
        <h3>Для локальных переменных - с момента объявления и до того момента, пока не останется ни одной переменной</h3>
        
  
  <p>
    и ни одного указателя, которые бы ссылались на эту переменную
<br>

    * В отличии C++, возврат указателя на локальную переменную - валидная конструкция. В этом случае
<br>

    переменная живет до тех пор, пока живет указатель на нее
<br>

    * В зависимости от того, выходит ли переменная за пределы функции или нет, память под нее может быть выделена
<br>

    в куче или на стеке (это решает `escape analysis` на этапе компиляции)
  </p>
  

  
  <div class="code"><pre>var global *int

func f() {                        func g() {
    var x int                         y := new(int) // local
    x = 1                             *y = 1
    global = &amp;x // escape         }
}</pre></div>
  

      
      <span class="pagenumber">31</span>
      </article>
  
  
  
      <article >
      
        <h2>Оператор присваивания `=`</h2>
      
      <span class="pagenumber">32</span>
      </article>
  
  
  
      <article >
      
        <h2>Можно присваивать несколько переменных (как и в случае объявления переменных)</h2>
      
      <span class="pagenumber">33</span>
      </article>
  
  
  
      <article >
      
        <h3>Значения с правой стороны вычисляются до того, как будет изменена хотя бы одна</h3>
        
  
  <p>
    переменная слева (`x, y = y, x%y`)
<br>

    * В случае, если нужно пропустить одно из присваиваний, можно использовать <code>_</code>
  </p>
  

  
  <div class="code"><pre>if _, found := values[key]; found {
        // ...
}</pre></div>
  

      
      <span class="pagenumber">34</span>
      </article>
  
  
  
      <article >
      
        <h3>Go позволяет определить новый тип на основе какого-либо другого (при этом это абсолютно другой тип, приведение - `T(val)`)</h3>
        
  
  <div class="code"><pre>type name underlying-type</pre></div>
  

      
      <span class="pagenumber">35</span>
      </article>
  
  
  
      <article >
      
        <h3>Можно определять типы и внутри функций, но обычно они встречаются на уровне пакета</h3>
        
  <div class="code" >


<pre><span num="1">package tempconv</span>
<span num="2"></span>
<span num="3">type Celsius float64</span>
<span num="4">type Fahrenheit float64</span>
<span num="5"></span>
<span num="6">const (</span>
<span num="7">    AbsoluteZeroC Celsius = -273.15</span>
<span num="8">    FreezingC     Celsius = 0</span>
<span num="9">    BoilingC      Celsius = 100</span>
<span num="10">)</span>
<span num="11"></span>
<span num="12">func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 &#43; 32) }</span>
<span num="13"></span>
<span num="14">func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }</span>
</pre>


</div>

      
      <span class="pagenumber">36</span>
      </article>
  
  
  
      <article >
      
        <h3>Типы, которые основаны на встроенных типах, можно приводить</h3>
        
  
  <p>
    к этому типу и между собой (однако само значение не изменяется при приведении!)
<br>

    * Операции над встроенными типами наследуются
<br>

    * Для новых типов можно определять методы, добавляя новое поведение
  </p>
  

      
      <span class="pagenumber">37</span>
      </article>
  
  
  
      <article >
      
        <h2>Имя пакета, обычно, не содержит символов `_` (например, `httprequest`)</h2>
      
      <span class="pagenumber">38</span>
      </article>
  
  
  
      <article >
      
        <h2>Экспортируемые объекты (переменные, константы, типы, функции) должны начинаться с большой буквы</h2>
      
      <span class="pagenumber">39</span>
      </article>
  
  
  
      <article >
      
        <h3>У каждого пакета может быть любое количество функций инициализации</h3>
        
  
  <div class="code"><pre>func init() {
    // ...
}</pre></div>
  

      
      <span class="pagenumber">40</span>
      </article>
  
  
  
      <article >
      
        <h2>Функции инициализации вызываются при инициализации пакета и не могут быть вызваны вручную</h2>
      
      <span class="pagenumber">41</span>
      </article>
  
  
  
      <article >
      
        <h3>Если пакет `a` импортирует пакет `b`, то в момент инициализации `a` можно быть уверенным,</h3>
        
  
  <p>
    что <code>b</code> уже инициализирован
<br>

    * Циклические импорты запрещены
  </p>
  

      
      <span class="pagenumber">42</span>
      </article>
  
  
  
      <article >
      
        <h2>Области видимости ограничены блоками (в  том числе `{` и `}` )</h2>
      
      <span class="pagenumber">43</span>
      </article>
  
  
  
      <article >
      
        <h2>Объявление внутри области видимости не видны снаружи, но видны во вложенных областях видимости</h2>
      
      <span class="pagenumber">44</span>
      </article>
  
  
  
      <article >
      
        <h2>Объекты могут иметь одни и те же имена, если располагаются в разных областях видимости</h2>
      
      <span class="pagenumber">45</span>
      </article>
  
  
  
      <article >
      
        <h3>Вложенная область видимости может &#34;перекрывать&#34; (`shadow`) имена из родительской</h3>
        
  
  <p>
    области видимости (нужно быть осторожным с <code>:=</code>)
  </p>
  

  
  <div class="code"><pre>var y = &#34;hello&#34;
{
        x, y := &#34;1&#34;, &#34;2&#34;
        fmt.Println(x, y)
}
fmt.Println(y)</pre></div>
  

      
      <span class="pagenumber">46</span>
      </article>
  
  
  
      <article >
      
        <h3>Список встроенных типов</h3>
        
  
  <div class="code"><pre>int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64
uintptr float32 float64 complex128
complex64 bool byte
rune string error</pre></div>
  

      
      <span class="pagenumber">47</span>
      </article>
  
  
  
      <article >
      
        <h3>Операции над встроенными типами (первые две строки имееют кратную форму, например, `&#43;=`)</h3>
        
  
  <div class="code"><pre>* / % &lt;&lt; &gt;&gt; &amp; &amp;^
&#43; - | ^
== != &lt; &lt;= &gt; &gt;=
&amp;&amp;
||</pre></div>
  

      
      <span class="pagenumber">48</span>
      </article>
  
  
  
      <article >
      
        <h2>`^` - XOR (бинарный) или NOT (унарный), а `&amp;^` - AND NOT</h2>
      
      <span class="pagenumber">49</span>
      </article>
  
  
  
      <article >
      
        <h3>Автоматическое выведение типа выводит всегда один и то же тип (для целых чисел - int),</h3>
        
  
  <p>
    нужно явно указывать тип чтобы получить, например, uint16 (`var x uint16 = 10`)
  </p>
  

      
      <span class="pagenumber">50</span>
      </article>
  
  
  
      <article >
      
        <h3>Строка - неизменяемая последовательность байт. Она может содержать произвольные данные (включая \0),</h3>
        
  
  <p>
    однако, обычно в строках содержат человекочитаемый текст
<br>

    * Строки интерпретируются в кодировке utf8 (поэтому нет типа <code>char</code>, а есть <code>rune</code>)
<br>

    * <code>str[i]</code> позволяет получить доступ к i-му байту (но это не обязательно i-й символ!)
<br>

    * <code>str[i:j]</code> позволяет получить подстроку с байтами с i-го по j-й (левая и правая границы могут быть опущены)
<br>

    * &#34;\n&#34; - строка с переносом строки, <code>\n</code> - строка из двух символов \ и n
<br>

    * Для работы с unicode-строками есть пакет &#34;unicode&#34; (и вложенные в него пакеты)
<br>

    * Строки могут быть приведены к <code>[]byte</code> и наоборот, для приведения к числам существует пакет <code>strconv</code>
  </p>
  

      
      <span class="pagenumber">51</span>
      </article>
  
  
  
      <article >
      
        <h3>Константы могут быть объявлены с помощью ключевого слова const</h3>
        
  
  <div class="code"><pre>const pi = 3.14
const (
        x = 10
        y
        num = 42
)</pre></div>
  

      
      <span class="pagenumber">52</span>
      </article>
  
  
  
      <article >
      
        <h2>Константами могут быть встроенные типы и пользовательские типы, основанные на встроенных</h2>
      
      <span class="pagenumber">53</span>
      </article>
  
  
  
      <article >
      
        <h3>Тип для констант может быть выведен сам с максимально компактным представлением</h3>
        
  
  <p>
    (при этом в местах использования не надо выполнять приведение типа)
<br>

    * Есть в блоке констант опущена правая часть, то очередная константа получает значение предыдущей
  </p>
  

      
      <span class="pagenumber">54</span>
      </article>
  
  
  
      <article >
      
        <h3>`iota` - константный генератор, начинает с 0 и увеличивается для каждой следующей константы</h3>
        
  
  <div class="code"><pre>type Weekday int
const (
        Sunday Weekday = iota
        Monday
        Tuesday
        ...
)

const (
        _ = 1 &lt;&lt; (10 * iota)
        KiB // 1024
        MiB // 1048576
)</pre></div>
  

      
      <span class="pagenumber">55</span>
      </article>
  
  

      <article>
        <h3>Thank you</h3>
        
      </article>

    </section>

    <div id="help">
      Use the left and right arrow keys or click the left and right
      edges of the page to navigate between slides.<br>
      (Press 'H' or navigate to hide this message.)
    </div>

    
    <script src='static/jquery.js'></script>
    <script src='static/jquery-ui.js'></script>
    <script src='static/playground.js'></script>
    <script src='static/play.js'></script>
    <script>initPlayground(new HTTPTransport());</script>
    

    <script>
      (function() {
        
        if (window["location"] && window["location"]["hostname"] == "talks.golang.org") {
          var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
          ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
          var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
        }
      })();
    </script>
  </body>
</html>
