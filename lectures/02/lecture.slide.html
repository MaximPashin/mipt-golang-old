
<!DOCTYPE html>
<html>
  <head>
    <title>Программирование на языке Go</title>
    <meta charset='utf-8'>
    <link rel="icon" href="static/favicon.ico">
    <script>
      var notesEnabled =  false ;
    </script>
    <script src='static/slides.js'></script>

    

    <script>
      
      if (window["location"] && window["location"]["hostname"] == "talks.golang.org") {
        var _gaq = _gaq || [];
        _gaq.push(["_setAccount", "UA-11222381-6"]);
        _gaq.push(["b._setAccount", "UA-49880327-6"]);
        window.trackPageview = function() {
          _gaq.push(["_trackPageview", location.pathname+location.hash]);
          _gaq.push(["b._trackPageview", location.pathname+location.hash]);
        };
        window.trackPageview();
        window.trackEvent = function(category, action, opt_label, opt_value, opt_noninteraction) {
          _gaq.push(["_trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
          _gaq.push(["b._trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
        };
      }
    </script>
  </head>

  <body style='display: none'>

    <section class='slides layout-widescreen'>

      <article>
        <h1>Программирование на языке Go</h1>
        
        
        
          <div class="presenter">
            
  
  <p>
    Лекция 2. Базовые конструкции языка
  </p>
  

          </div>
        
      </article>

  
  
      <article >
      
        <h3>Имена переменных, констант, функций, ...</h3>
        <ul>
<li>
<p>Должны начинаться с буквы (unicode) или символа <code>_</code></p>
</li>
<li>
<p>Могут содержать в себе буквы (unicode), цифры и символ <code>_</code></p>
</li>
<li>
<p>Регистр имеет значение (<code>hello</code> и <code>Hello</code> - разные имена)</p>
</li>
<li>
<p>Регистр первой буквы влияет на область видимости глобальных переменных, констант, функций и типов:</p>
<pre><code>  var Foo = &quot;foo&quot; // можно обращаться из других пакетов
  var bar = &quot;bar&quot; // можно обращаться только из того же пакета
</code></pre>
</li>
<li>
<p>Имена не имеют ограничений на длину, однако, принято, чтобы маложивущие объекты имели краткое и лаконичное название</p>
</li>
<li>
<p>Для именования используется <code>CamelCase</code>, <code>snake_case</code> допустим синтаксически, но никто его не использует</p>
</li>
<li>
<p>Сокращения аббревиатур: <code>htmlTags</code> (не <code>hTMLTags</code>), <code>HTMLTags</code> (не <code>HtmlTags</code>), <code>marshalJSON</code> (не <code>marshalJson</code>)</p>
</li>
</ul>

      
      <span class="pagenumber">2</span>
      </article>
  
  
  
      <article >
      
        <h3>Ключевые слова</h3>
        <ul>
<li>
<p>Ключевые слова не могут быть использованы в качестве имен:</p>
<pre><code>  break     default     func    interface   select
  case      defer       go      map         struct
  chan      else        goto    package     switch
  const     fallthrough if      range       type
  continue  for         import  return      var
</code></pre>
</li>
<li>
<p>Кроме этого, есть <code>predeclared</code> имена, которые могут использоваться в качестве имен других объектов</p>
<pre><code>  true false iota nil

  int int8 int16 int32 int64
  uint uint8 uint16 uint32 uint64
  uintptr float32 float64 complex128
  complex64 bool byte
  rune string error

  make len cap new append copy close delete complex real imag
  panic recover</code></pre>
</li>
</ul>

      
      <span class="pagenumber">3</span>
      </article>
  
  
  
      <article >
      
        <h3>Объявления</h3>
        <ul>
<li><code>var</code> - объявление переменной</li>
<li><code>const</code> - объявление константы</li>
<li><code>type</code> - объявление пользовательского типа</li>
<li><code>func</code> - объявление функции или метода</li>
</ul>

      
      <span class="pagenumber">4</span>
      </article>
  
  
  
      <article >
      
        <h3>Переменные</h3>
        <pre><code>    var name type = expression
</code></pre>
<ul>
<li>
<p><code>type</code> или <code>expression</code> могут отсутствовать, но не оба одновременно</p>
</li>
<li>
<p>При отсутствии инициализации, переменная инициализируется <code>zero value</code> (0, &quot;&quot;, nil и т.д.)</p>
</li>
<li>
<p>Можно объявить несколько переменных (и в том числе инициализировать их):</p>
<pre><code>  var i, j int = 1, 2
  var name, value = &quot;number&quot;, 42 // типы могут быть разными, но только если они выводятся
</code></pre>
</li>
<li>
<p>Глобальные переменные инициализируются (и выделяются в памяти) до вызова <code>main</code>,
локальные переменные инициализируются в момент выполнения их определения</p>
</li>
<li>
<p>Несколько переменных могут быть инициализированы результатом вызова функции:</p>
<pre><code>  var f, err = os.Open(&quot;filename.txt&quot;)</code></pre>
</li>
</ul>

      
      <span class="pagenumber">5</span>
      </article>
  
  
  
      <article >
      
        <h3>Краткий синтаксис объявления переменных</h3>
        <ul>
<li>
<p>Если объявление переменной происходит совместно с ее инициализацией, то можно использовать краткий синтаксис:</p>
<pre><code>  name := expression // var name = expression
</code></pre>
</li>
<li>
<p>Краткий синтаксис не может быть использован для глобальных переменных</p>
</li>
<li>
<p>Хотя бы одна из переменных должна быть необъявленной, в этом случае для уже объявленных переменных
будет вызвано просто присваивание</p>
<pre><code>  i, j := 0, 1 // ok
  i, j := 2, 3 // error, i and j already declared
  x, i := 2, 3 // ok
  i, j = 2, 3  // ok
</code></pre>
</li>
<li>
<p>Обычно для переменных, инициализируемых <code>zero value</code> (т.е. без инициализации) используют синтаксис с <code>var</code></p>
</li>
</ul>

      
      <span class="pagenumber">6</span>
      </article>
  
  
  
      <article >
      
        <h3>Указатели</h3>
        <ul>
<li>Указатель хранит адрес некоторой области в памяти (почти всегда - переменной)</li>
<li><code>&amp;</code> - взятие адреса, <code>*</code> - разыменование адреса</li>
<li>Для типа <code>T</code> тип указателя на переменную этого типа - <code>*T</code> (может быть указатель на указатель и т.д.)</li>
<li>Указатели можно сравнивать, но не выполнять арифметические операции</li>
<li>С некоторым упрощением указатели - это другие имена для одной и той же переменной, изменение через указатель
меняет значение исходной переменной</li>
<li>Так как аргументы функции всегда передаются по значению, то чтобы функция могла изменять переменную вовне
надо передать указатель</li>
</ul>

      
      <span class="pagenumber">7</span>
      </article>
  
  
  
      <article >
      
        <h3>Функция `new`</h3>
        <ul>
<li>
<p>Принимает в качестве аргумента тип, создает неименованную переменную этого типа и возвращает на нее указатель</p>
<pre><code>  x := new(int) // то же самое, что var dummy int; x = &amp;dummy
</code></pre>
</li>
<li>
<p>Функция <code>new</code> всегда возвращает адрес новой переменной (возможное исключение - пустые типы размера 0,
например <code>struct{}</code> или <code>[0]int</code>)</p>
</li>
</ul>

      
      <span class="pagenumber">8</span>
      </article>
  
  
  
      <article >
      
        <h3>Время жизни переменных</h3>
        <ul>
<li>
<p>Для глобальных переменных - все время исполнения программы</p>
</li>
<li>
<p>Для локальных переменных - с момента объявления и до того момента, пока не останется ни одной переменной
и ни одного указателя, которые бы ссылались на эту переменную</p>
</li>
<li>
<p>В отличии C++, возврат указателя на локальную переменную - валидная конструкция. В этом случае
переменная живет до тех пор, пока живет указатель на нее</p>
</li>
<li>
<p>В зависимости от того, выходит ли переменная за пределы функции или нет, память под нее может быть выделена
в куче или на стеке (это решает <code>escape analysis</code> на этапе компиляции)</p>
<pre><code>  var global *int

  func f() {                        func g() {
      var x int                         y := new(int) // local
      x = 1                             *y = 1
      global = &amp;x // escape         }
  }</code></pre>
</li>
</ul>

      
      <span class="pagenumber">9</span>
      </article>
  
  
  
      <article >
      
        <h3>Присваивание</h3>
        <ul>
<li>
<p>Оператор присваивания <code>=</code></p>
</li>
<li>
<p>Можно присваивать несколько переменных (как и в случае объявления переменных)</p>
</li>
<li>
<p>Значения с правой стороны вычисляются до того, как будет изменена хотя бы одна
переменная слева (<code>x, y = y, x%y</code>)</p>
</li>
<li>
<p>В случае, если нужно пропустить одно из присваиваний, можно использовать <code>_</code></p>
<pre><code>  if _, found := values[key]; found {
          // ...
  }</code></pre>
</li>
</ul>

      
      <span class="pagenumber">10</span>
      </article>
  
  
  
      <article >
      
        <h3>Определение типа</h3>
        <ul>
<li>
<p>Go позволяет определить новый тип на основе какого-либо другого (при этом это абсолютно другой тип, приведение - <code>T(val)</code>)</p>
<pre><code>  type name underlying-type
</code></pre>
</li>
<li>
<p>Можно определять типы и внутри функций, но обычно они встречаются на уровне пакета</p>
</li>
</ul>

  <div class="code" >
<pre><span num="1">package tempconv</span>
<span num="2"></span>
<span num="3">type Celsius float64</span>
<span num="4">type Fahrenheit float64</span>
<span num="5"></span>
<span num="6">const (</span>
<span num="7">    AbsoluteZeroC Celsius = -273.15</span>
<span num="8">    FreezingC     Celsius = 0</span>
<span num="9">    BoilingC      Celsius = 100</span>
<span num="10">)</span>
<span num="11"></span>
<span num="12">func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 &#43; 32) }</span>
<span num="13"></span>
<span num="14">func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }</span>
</pre>
</div>

      
      <span class="pagenumber">11</span>
      </article>
  
  
  
      <article >
      
        <h3>Определение типа</h3>
        <ul>
<li>Типы, которые основаны на встроенных типах, можно приводить
к этому типу и между собой (однако само значение не изменяется при приведении!)</li>
<li>Операции над встроенными типами наследуются</li>
<li>Для новых типов можно определять методы, добавляя новое поведение</li>
</ul>

      
      <span class="pagenumber">12</span>
      </article>
  
  
  
      <article >
      
        <h3>Пакеты и импорты</h3>
        <ul>
<li>
<p>Имя пакета, обычно, не содержит символов <code>_</code> (например, <code>httprequest</code>)</p>
</li>
<li>
<p>Экспортируемые объекты (переменные, константы, типы, функции) должны начинаться с большой буквы</p>
</li>
<li>
<p>У каждого пакета может быть любое количество функций инициализации</p>
<pre><code>  func init() {
      // ...
  }
</code></pre>
</li>
<li>
<p>Функции инициализации вызываются при инициализации пакета и не могут быть вызваны вручную</p>
</li>
<li>
<p>Если пакет <code>a</code> импортирует пакет <code>b</code>, то в момент инициализации <code>a</code> можно быть уверенным,
что <code>b</code> уже инициализирован</p>
</li>
<li>
<p>Циклические импорты запрещены</p>
</li>
</ul>

      
      <span class="pagenumber">13</span>
      </article>
  
  
  
      <article >
      
        <h3>Область видимости</h3>
        <ul>
<li>
<p>Области видимости ограничены блоками (в  том числе <code>{</code> и <code>}</code> )</p>
</li>
<li>
<p>Объявление внутри области видимости не видны снаружи, но видны во вложенных областях видимости</p>
</li>
<li>
<p>Объекты могут иметь одни и те же имена, если располагаются в разных областях видимости</p>
</li>
<li>
<p>Вложенная область видимости может &quot;перекрывать&quot; (<code>shadow</code>) имена из родительской
области видимости (нужно быть осторожным с <code>:=</code>)</p>
<pre><code>  var y = &quot;hello&quot;
  {
          x, y := &quot;1&quot;, &quot;2&quot;
          fmt.Println(x, y)
  }
  fmt.Println(y)</code></pre>
</li>
</ul>

      
      <span class="pagenumber">14</span>
      </article>
  
  
  
      <article >
      
        <h3>Базовые типы</h3>
        <ul>
<li>
<p>Список встроенных типов</p>
<pre><code>  int int8 int16 int32 int64
  uint uint8 uint16 uint32 uint64
  uintptr float32 float64 complex128
  complex64 bool byte
  rune string error
</code></pre>
</li>
<li>
<p>Операции над встроенными типами (первые две строки имееют кратную форму, например, <code>+=</code>)</p>
<pre><code>  * / % &lt;&lt; &gt;&gt; &amp; &amp;^
  + - | ^
  == != &lt; &lt;= &gt; &gt;=
  &amp;&amp;
  ||
</code></pre>
</li>
<li>
<p><code>^</code> - XOR (бинарный) или NOT (унарный), а <code>&amp;^</code> - AND NOT</p>
</li>
<li>
<p>Автоматическое выведение типа выводит всегда один и то же тип (для целых чисел - int),
нужно явно указывать тип чтобы получить, например, uint16 (<code>var x uint16 = 10</code>)</p>
</li>
</ul>

      
      <span class="pagenumber">15</span>
      </article>
  
  
  
      <article >
      
        <h3>Строки</h3>
        <ul>
<li>Строка - неизменяемая последовательность байт. Она может содержать произвольные данные (включая \0),
однако, обычно в строках содержат человекочитаемый текст</li>
<li>Строки интерпретируются в кодировке utf8 (поэтому нет типа <code>char</code>, а есть <code>rune</code>)</li>
<li><code>str[i]</code> позволяет получить доступ к i-му байту (но это не обязательно i-й символ!)</li>
<li><code>str[i:j]</code> позволяет получить подстроку с байтами с i-го по j-й (левая и правая границы могут быть опущены)</li>
<li>&quot;\n&quot; - строка с переносом строки, <code>\n</code> - строка из двух символов \ и n</li>
<li>Для работы с unicode-строками есть пакет &quot;unicode&quot; (и вложенные в него пакеты)</li>
<li>Строки могут быть приведены к <code>[]byte</code> и наоборот, для приведения к числам существует пакет <code>strconv</code></li>
</ul>

      
      <span class="pagenumber">16</span>
      </article>
  
  
  
      <article >
      
        <h3>Константы</h3>
        <ul>
<li>
<p>Константы могут быть объявлены с помощью ключевого слова const</p>
<pre><code>  const pi = 3.14
  const (
          x = 10
          y
          num = 42
  )
</code></pre>
</li>
<li>
<p>Константами могут быть встроенные типы и пользовательские типы, основанные на встроенных</p>
</li>
<li>
<p>Тип для констант может быть выведен сам с максимально компактным представлением
(при этом в местах использования не надо выполнять приведение типа)</p>
</li>
<li>
<p>Есть в блоке констант опущена правая часть, то очередная константа получает значение предыдущей</p>
</li>
</ul>

      
      <span class="pagenumber">17</span>
      </article>
  
  
  
      <article >
      
        <h3>iota</h3>
        <ul>
<li>
<p><code>iota</code> - константный генератор, начинает с 0 и увеличивается для каждой следующей константы</p>
<pre><code>  type Weekday int
  const (
          Sunday Weekday = iota
          Monday
          Tuesday
          ...
  )

  const (
          _ = 1 &lt;&lt; (10 * iota)
          KiB // 1024
          MiB // 1048576
  )</code></pre>
</li>
</ul>

      
      <span class="pagenumber">18</span>
      </article>
  
  

      <article>
        <h3>Thank you</h3>
        
          <div class="presenter">
            
  
  <p>
    Лекция 2. Базовые конструкции языка
  </p>
  

          </div>
        
      </article>

    </section>

    <div id="help">
      Use the left and right arrow keys or click the left and right
      edges of the page to navigate between slides.<br>
      (Press 'H' or navigate to hide this message.)
    </div>

    
    <script src='static/jquery.js'></script>
    <script src='static/jquery-ui.js'></script>
    <script src='static/playground.js'></script>
    <script src='static/play.js'></script>
    <script>initPlayground(new HTTPTransport());</script>
    

    <script>
      (function() {
        
        if (window["location"] && window["location"]["hostname"] == "talks.golang.org") {
          var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
          ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
          var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
        }
      })();
    </script>
  </body>
</html>
