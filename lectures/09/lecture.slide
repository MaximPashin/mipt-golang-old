# Программирование на языке Go

Лекция 8. Generics

## Generics

* Дженерики являются одним из замых значительных изменений в языке со времен первого open source релиза
* Дженерики позволяют писать обобщенные функции и типы, избавляя от необходимости писать много дублирующегося кода для разных типов
* В релиз 1.18 были добавлены: type parameters для функций и типов, определение интерфейсов как набора типов и автоматический вывод типов при вызовах

## Type parameters

* Функции и типы могут теперь иметь отдельный список параметров, описывающий типы, используемые для описания аргументов или внутренностей типа
* В момент вызова с такими параметрами происходит инстанцирование, состоящее из двух шагов: подстановка конкретых типов на основании аргументов и проверка компилятором совместимости конкретных типов с ограничениями
* После инстанцирования получается (скрытая от нас) обычная функция или тип, что никак не влияет на производительность программы

## Type sets

* Наподобие того, как обычный тип описывает множество значений агрумента, "тип" параметра-типа определяет множество типов, подходящих для аргумента
* Такой мета-тип называется **type constraint**. Некоторое количетсво таких типов можно найти в пакете [constraints](https://pkg.go.dev/golang.org/x/exp/constraints)
* Type constraint должен являться интерфейсом, таким образом, дженерики несколько расширяют понятие интерфейса

## Type sets

* Мы можем посмотреть на интерфейс как "ограничение", описывающее множество типов, удовлетворяющих этому интерфейсу
* С этой точки зрения интерфейс описывает множество типов. И в go1.18 появилась возможность явно добавлять типы в это множетсво (при этом не обязательно содержащие интерфейсы)
* Таким образом `interface {int | bool | string}` описывает интерфейс, которому удовлетворяют три типа (которые, при этом, не имеют типов)
* Синтаксис `~string` говорит, что в множество включен не только тип `string`, но и типы, основанные на нем
* Дополнительно, появилось ключевое слово `any`, эквивалентное `interface{}`

## Type inference

* Type inference позволяет опускать type parameters в большинстве случаев, автоматически выводя их из аргументов
* Вывод типа может работать на основании аргументов и на основании других type constraints
* Если type inference завершился неуспешно, всегда можно вручную указать список type parameters