
<!DOCTYPE html>
<html>
  <head>
    <title>Программирование на языке Go</title>
    <meta charset='utf-8'>
    <link rel="icon" href="static/favicon.ico">
    <script>
      var notesEnabled =  false ;
    </script>
    <script src='static/slides.js'></script>

    

    <script>
      
      if (window["location"] && window["location"]["hostname"] == "talks.golang.org") {
        var _gaq = _gaq || [];
        _gaq.push(["_setAccount", "UA-11222381-6"]);
        _gaq.push(["b._setAccount", "UA-49880327-6"]);
        window.trackPageview = function() {
          _gaq.push(["_trackPageview", location.pathname+location.hash]);
          _gaq.push(["b._trackPageview", location.pathname+location.hash]);
        };
        window.trackPageview();
        window.trackEvent = function(category, action, opt_label, opt_value, opt_noninteraction) {
          _gaq.push(["_trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
          _gaq.push(["b._trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
        };
      }
    </script>
  </head>

  <body style='display: none'>

    <section class='slides layout-widescreen'>

      <article>
        <h1>Программирование на языке Go</h1>
        
        
        
          <div class="presenter">
            
  
  <p>
    Лекция 5. Конкурентность и параллелизм. Горутины. Каналы
  </p>
  

          </div>
        
      </article>

  
  
      <article >
      
        <h3>Многопоточность</h3>
        <ul>
<li>Последние годы (даже десятилетия) нет существенного прогресса в производительности процессоров (на одно ядро)</li>
<li>Даже в смартфонах процессоры имеют по несколько ядер</li>
<li>В случае пользовательских устройств многозадачность системы утилизирует все ядра даже в случае
программ, написанных для запуска на одном ядре (однако такие программы, все равно, обычно используют несколько потоков)</li>
<li>В случае серверов, обслуживающих пользовательские запросы, обычно запущен один основной процесс,
утилизирующий ресурсы по максимуму</li>
<li>Многопоточные программы позволяют утилизировать по максимуму мощность многоядерных процессоров,
однако, писать корректные многопоточные программы значительно сложнее</li>
</ul>

      
      <span class="pagenumber">2</span>
      </article>
  
  
  
      <article >
      
        <h3>Конкурентность</h3>
        <ul>
<li>В русской литературе, зачастую, не выделяют отдельно конкурентность, относя ее к параллелизму</li>
<li>Однако, конкурентность != параллелизм</li>
<li>Конкурентная программа может быть запущена на одном потоке, при этом работать производительнее
аналогичной многопоточной программы (например, сервер, где много времени процесс ожидает данные по сети)</li>
<li>Go изначально проектировался так, что писать конкурентные (и многопоточные) программы в нем легко</li>
<li>Более того, сетевой стек написан с использованием асинхронных операций, что позволяет избежать
ожидания сетевых данных, отдав исполнение другой части кода</li>
</ul>

      
      <span class="pagenumber">3</span>
      </article>
  
  
  
      <article >
      
        <h3>Конкурентное программирование в Go</h3>
        <ul>
<li>Go предоставляет возможность использовать два стиля конкурентного программирования</li>
<li>Один из них - communicating sequential processes (CSP) - передача данных между независимыми &quot;исполнителями&quot;
(горутинами) через методы взаимодействия (каналы)</li>
<li>Другой, более традиционный - shared memory multithreading - враимодействие конкурентных &quot;исполнителей&quot;
с общей памятью (с синхронизацией доступа через примитивы синхронизации, такие как мьютекс и другие)</li>
</ul>

      
      <span class="pagenumber">4</span>
      </article>
  
  
  
      <article >
      
        <h3>Горутины</h3>
        <ul>
<li>
<p>Горутина (goroutine) - отдельный &quot;исполнитель&quot; некоторого кода, независимый от других</p>
</li>
<li>
<p>В отличии от обычных функций (routine), горутины исполняются конкурентно (параллельно или чередуя исполнение)</p>
</li>
<li>
<p>Следует учитывать, что горутина - не то же самое, что поток (хотя сценарии использования очень похожие)</p>
</li>
<li>
<p>В любой программе есть, как минимум, одна горутина - в ней вызывается <code>main</code></p>
</li>
<li>
<p>Чтобы вызвать функцию в отдельной горутине, достаточно перед вызовом функции добавить ключевое слово <code>go</code></p>
<pre><code>  go foo(42)</code></pre>
</li>
</ul>

      
      <span class="pagenumber">5</span>
      </article>
  
  
  
      <article >
      
        <h3>Горутины</h3>
        <ul>
<li>Несмотря на то, что у программы может быть несколько горутин в исполнении, как только завершается горутина
с <code>main</code>, процесс завершается (не дожидаясь исполнения других горутин). Для ожидания можно использовать <code>sync.WaitGroup</code></li>
<li>Для горутины нет никакого отдельного объекта, который бы позволял управлять ее (в частности, завершать ее исполнение).
Горутина завершается (и освобождает выделенные на нее ресурсы) только в момент завершения функции, которая была в ней запущена</li>
<li>Существуют механизмы (например, пакет <code>context</code>), позволяющие сообщать в горутины (в которых, обычно, выполняются долгие операции,
в реальных программах - в основном, ожидание чего то), что ее можно досрочно завершить</li>
</ul>

      
      <span class="pagenumber">6</span>
      </article>
  
  
  
      <article >
      
        <h3>Горутины</h3>
        <ul>
<li>Фактически, горутина то же самое, что можно встретить в других языках программирования под
названием сопрограмма (coroutine, корутина)</li>
<li>Основная особенность корутин - они могут прерывать свое исполнение и продолжать с того же места, как будто прерывания не было</li>
<li>Это позволяет отдавать исполнение (т.е. CPU) другой корутине, пока первая ожидает чего-то (например, I/O-операции или
освобождения примитива синхронизации)</li>
<li>Для удобного использования корутин на уровне приложения существует scheduler (который работает независимо
от системного), в случае горутинг этим занимается runtime Go.</li>
</ul>

      
      <span class="pagenumber">7</span>
      </article>
  
  
  
      <article >
      
        <h3>Горутины</h3>
        <ul>
<li>При старте программы создается несколько потоков (указывается в переменной окружения <code>GOMAXPROCS</code>, по умолчанию - количество ядер),
на которых запускаются горутины (параллельно в случае нескольких потоков)</li>
<li>Горутины могут переключаться (вызов функции, блокировка, вызов <code>runtime.Gosched</code>), давая исполнение другим горутинам</li>
<li>В большинстве случаев, это выглядит как &quot;параллельное&quot; исполнение множества горутин, однако, можно
написать горутину так, что она не будет снята с исполнения длительное время (в ней не будет точек переключения)</li>
<li>Например, это могут быть какие-то численные вычисления с множеством циклов, не вызывающие другие функции</li>
<li>В этом случае, рекомендуется, вручную вызывать <code>runtime.Gosched</code></li>
</ul>

      
      <span class="pagenumber">8</span>
      </article>
  
  
  
      <article >
      
        <h3>Горутины</h3>
        <ul>
<li>У каждой горутины существует свой стек исполнения, равный нескольким килобайтам</li>
<li>Переключение горутины для исполнения на потоке - операция, сильно более дешевая, чем переключение системного потока</li>
<li>Таким образом, для программы на Go нормальная ситуация, когда одновременно существуют сотни и даже тысячи горутин
(в случае такого количества потоков процесс может сильно тормозить из-за оверхэда на переключение контекстов)</li>
<li>Подробнее: <a href="https://habr.com/ru/post/141853/" target="_blank" rel="noopener">раз</a>, <a href="https://habr.com/ru/company/otus/blog/527748/" target="_blank" rel="noopener">два</a></li>
<li><a href="https://habr.com/ru/post/201826/" target="_blank" rel="noopener">Про асинхронность и корутины в C++</a></li>
</ul>

      
      <span class="pagenumber">9</span>
      </article>
  
  
  
      <article >
      
        <h3>Каналы</h3>
        <ul>
<li>
<p>Каналы позволяют нескольким горутинам обмениваться информацией (но не только)</p>
</li>
<li>
<p>В канал можно что-то записать и прочитать (потокобезопасно)</p>
</li>
<li>
<p>Канал типизирован (так же, как <code>map</code> и <code>slice</code>), т.е. можно передавать объекты только определенного типа</p>
</li>
<li>
<p>Тип канала - <code>chan T</code>, где <code>T</code> - некоторый тип. Канал должен создаваться через <code>make</code></p>
<pre><code>  ch := make(chan int)
</code></pre>
</li>
<li>
<p>Также существуют типы однонаправленных каналов (<code>&lt;-chan T</code>, <code>chan&lt;- T</code>) - можно контролировать,
что из канала никто не будет читать либо что в канал никто не будет писать</p>
</li>
<li>
<p>Как и в случае с <code>map</code>, канал - reference type, т.е. при передаче куда либо он будет передаваться &quot;по ссылке&quot;</p>
</li>
</ul>

      
      <span class="pagenumber">10</span>
      </article>
  
  
  
      <article >
      
        <h3>Каналы</h3>
        <ul>
<li>
<p>Zero value для канала - nil</p>
</li>
<li>
<p>Каналы могут сравниваться на равенство между собой и с nil</p>
</li>
<li>
<p>В канал можно записать значение и прочитать значение из него</p>
<pre><code>  val := &lt;-ch
  ch &lt;- newVal
</code></pre>
</li>
<li>
<p>Кроме этого, канал можно закрыть (<code>close(ch)</code>), при этом в канал нельзя писать (вызовет панику),
но можно читать - будет возвращено zero value</p>
</li>
<li>
<p>При чтении из канала можно получить вторым аргументом, было ли прочитано значение</p>
<pre><code>  val, ok := &lt;-ch</code></pre>
</li>
</ul>

      
      <span class="pagenumber">11</span>
      </article>
  
  
  
      <article >
      
        <h3>Каналы</h3>
        <ul>
<li>Канал может быть буферизированным или нет</li>
<li>Для создания буферизированного канала необходимо в <code>make</code> вторым аргументом передать размер буфера</li>
<li>Небуферизированный канал - буфер размера 0</li>
<li>Операции с каналами могут быть блокирующими: запись в канал сверх буфера заблокируется до того момента,
пока кто-то не прочитает значение из канала; чтение из пустого канала (никто не пишет в него и ничего нет в буфере)
тоже заблокирует выполнение</li>
<li>Небуферизированные каналы можно использовать для синхронизации каких-либо дуйствий в разных горутинах
(т.к. для разблокировки операции нужно, чтобы одновременно кто-то читал и писал)</li>
</ul>

      
      <span class="pagenumber">12</span>
      </article>
  
  
  
      <article >
      
        <h3>Каналы</h3>
        <ul>
<li>Зачастую каналы используются для составления пайплайнов (pipeline): несколько горутин принимают
значения из канала и передают в другой канал, выстраивая цепочку обработки</li>
<li>При этом, самое медленное звено в цепочке определяет скорость обработки данных</li>
<li>Но можно сделать несколько параллельных звеньев, которые будут читать из одной очереди и писать в одну очередь</li>
</ul>

      
      <span class="pagenumber">13</span>
      </article>
  
  
  
      <article >
      
        <h3>Каналы</h3>
        <ul>
<li>
<p>По значениям в канале можно итерироваться через range</p>
<pre><code>  for val := range ch {...}
  // Эквивалентно
  for {
      val, ok := &lt;-ch
      if !ok {
          break
      }
      ...
  }
</code></pre>
</li>
<li>
<p>Единственный способ выйти из такого цикла - закрыть канал (обычно, закрывает кто-то снаружи)</p>
</li>
</ul>

      
      <span class="pagenumber">14</span>
      </article>
  
  
  
      <article >
      
        <h3>Мультиплексирование</h3>
        <ul>
<li>
<p>Мультиплексирование позволяет объединять чтение (или запись) для нескольких каналов</p>
</li>
<li>
<p>Из-за удобства этого механизма некоторые сущности, не связанные с коммуникацией, используют каналы
(<code>context.Done</code>, <code>time.After</code>)</p>
</li>
<li>
<p>Кроме этого, данный механизмм позволяет прочитать или записать что-то без блокировки (т.е. в случае, если бы
случилась блокировка, мы выйдем, ничего не записав и не прочитав)</p>
<pre><code>  select {
  case &lt;-ch:
      // ...
  case &lt;-ch2:
      // ...
  default:
      // ...
  }</code></pre>
</li>
</ul>

      
      <span class="pagenumber">15</span>
      </article>
  
  
  
      <article >
      
        <h3>Отмена исполнения горутин</h3>
        <ul>
<li>Есть несколько способов (фактически, один, но разными сущностями) правильно отменить исполнение горутины</li>
<li>Один - передать канал, из которого в select дожидаться сообщения о том, что можно завершиться</li>
<li>Недостаток - сложно отменить некоторые потенциально долгие вещи (такие, как http-запрос)</li>
<li>Другой способ - передавать контекст (пакет <code>context</code>)</li>
<li>Две ключевых роли контекста - передача сигнала об отмене и передача данных далее при обработке (например, пользовательского запроса)</li>
</ul>

      
      <span class="pagenumber">16</span>
      </article>
  
  

      <article>
        <h3>Thank you</h3>
        
          <div class="presenter">
            
  
  <p>
    Лекция 5. Конкурентность и параллелизм. Горутины. Каналы
  </p>
  

          </div>
        
      </article>

    </section>

    <div id="help">
      Use the left and right arrow keys or click the left and right
      edges of the page to navigate between slides.<br>
      (Press 'H' or navigate to hide this message.)
    </div>

    
    <script src='static/jquery.js'></script>
    <script src='static/jquery-ui.js'></script>
    <script src='static/playground.js'></script>
    <script src='static/play.js'></script>
    <script>initPlayground(new HTTPTransport());</script>
    

    <script>
      (function() {
        
        if (window["location"] && window["location"]["hostname"] == "talks.golang.org") {
          var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
          ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
          var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
        }
      })();
    </script>
  </body>
</html>
